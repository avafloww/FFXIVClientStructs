using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;

namespace RustExporter;

public class RustRootModule : RustModule
{
    public static readonly RustRootModule Instance = new();

    public RustRootModule() : base(null, "crate")
    {
    }

    public void ProcessCopyTaints()
    {
        int tainted;
        for (var i = 0;; i++)
        {
            tainted = GetAllStructsRecursive()
                .Where(rs => rs.TypeRefs.Any(typeRef => typeRef.Declaration.IsCopyTainted))
                .Sum(rs => rs.MarkAsCopyTainted());

            Console.WriteLine($"ProcessCopyTaints (pass {i}): {tainted} newly copy-tainted structs");
            if (i > 0 && tainted == 0)
            {
                break;
            }
        }
    }

    // virtual functions only get exported on the most derived types
    // i.e., we want to export AtkUnitBase vfs on AddonSelectString, but not on AtkUnitBase
    // Rust has no struct inheritance, so we need to collect the .NET types, remove virtual functions from base Rust types,
    // and then export the virtual functions on the most derived types
    public void ProcessVirtualFunctions()
    {
        foreach (var rs in GetAllStructsRecursive().Where(rs => rs.OriginalClrType != null))
        {
            // we don't need to touch anything if the vtable signature is valid
            if (rs.VTableSignature != null) continue;

            // check for any virtual functions and remove them from the base type
            var virtualFunctions = rs.Functions.Where(fn => fn.VirtualFunction != null).ToList();
            if (virtualFunctions.Count == 0) continue;

            // remove virtual functions from the base type
            foreach (var fn in virtualFunctions)
            {
                rs.Functions.Remove(fn);
            }

            // spread them to subtypes (recursively) with valid vtable signatures
            foreach (var subStruct in GetAllStructsRecursive()
                         .Where(subStruct => subStruct.OriginalClrType != null)
                         .Where(subStruct => subStruct.VTableSignature != null))
            {
                // is this a subtype of the original struct?
                // this is defined as a substruct if any field with FieldOffset[0] is of the original type
                if (!subStruct.OriginalClrType!
                        .GetFields()
                        .Where(finfo => !Attribute.IsDefined(finfo, typeof(ObsoleteAttribute)))
                        .Where(finfo => finfo.FieldType == rs.OriginalClrType)
                        .Any(finfo => finfo.GetCustomAttribute<FieldOffsetAttribute>()?.Value == 0))
                {
                    continue;
                }

                // add virtual functions to the subtype
                foreach (var fn in virtualFunctions)
                {
                    // only add the function if it doesn't already exist
                    if (subStruct.Functions.Any(subFn => subFn.Name == fn.Name)) continue;
                    subStruct.Functions.Add(RustFunction.FromBaseMethod(fn, subStruct));
                }

                Console.WriteLine($"ProcessVirtualFunctions: base {rs.Name} -> {subStruct.Name}");
            }
        }
    }

    public override void Export(StringBuilder builder, int indentLevel)
    {
        // Get the current git commit hash of the repo, appending "-dirty" for uncommitted changes
        var gitProcess = new Process
        {
            StartInfo =
            {
                FileName = "git",
                Arguments = "describe --always --dirty",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                CreateNoWindow = true
            }
        };
        gitProcess.Start();
        gitProcess.WaitForExit();

        var gitOutput = gitProcess.StandardOutput.ReadToEnd().Trim();
        builder.AppendLine($"// rev: {gitOutput}");
        builder.AppendLine("// This file is automatically generated by RustExporter. Do not edit manually.");
        builder.AppendLine("#![allow(warnings)]");
        builder.AppendLine(
            "use crate::{Addressable, AddressableMut, ResolvableStaticAddress, ResolvableMemberFunction, ResolvableVTable, ResolvableVirtualFunction};");

        // export helper functions
        var indent = Exporter.Indent(indentLevel + 1);

        // resolve vtables
        builder.AppendLine("pub(crate) unsafe fn resolve_vtables(resolver: &crate::VTableResolver) {");
        foreach (var rs in GetAllStructsRecursive()
                     .Where(rs => rs.VTableSignature != null))
        {
            builder.AppendLine(
                $"{indent}{rs.Name}::set_address(&resolver(&{rs.Name}::SIGNATURE));");
        }

        builder.AppendLine("}");

        // resolve static addresses
        builder.AppendLine("pub(crate) unsafe fn resolve_static_addresses(resolver: &crate::StaticAddressResolver) {");
        foreach (var fn in GetAllStructsRecursive()
                     .SelectMany(rs => rs.Functions)
                     .Where(fn => fn.StaticAddress != null))
        {
            builder.AppendLine(
                $"{indent}{fn.FullGeneratedName}::set_address(&resolver(&{fn.FullGeneratedName}::SIGNATURE));");
        }

        builder.AppendLine("}");

        // resolve member functions
        builder.AppendLine("pub(crate) unsafe fn resolve_member_functions(resolver: &crate::MemberFunctionResolver) {");
        builder.AppendLine($"{indent}// resolve member functions with signatures");
        foreach (var fn in GetAllStructsRecursive()
                     .SelectMany(rs => rs.Functions)
                     .Where(fn => fn.MemberFunction != null))
        {
            builder.AppendLine(
                $"{indent}{fn.FullGeneratedName}::set_address(&resolver(&{fn.FullGeneratedName}::SIGNATURE));");
        }

        builder.AppendLine();
        builder.AppendLine($"{indent}// resolve member functions by vtable index");
        foreach (var fn in GetAllStructsRecursive()
                     .SelectMany(rs => rs.Functions)
                     .Where(fn => fn.VirtualFunction != null))
        {
            builder.AppendLine(
                $"{indent}{fn.FullGeneratedName}::set_address(&Some({fn.Owner.Name}::address().expect(\"unresolved vtable: {fn.Owner.BaseName}\").offset({fn.VirtualFunction!.Index})));");
        }

        builder.AppendLine("}");

        // export members
        foreach (var member in _members)
        {
            member.Value.Export(builder, indentLevel);
        }
    }
}