using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using FFXIVClientStructs.FFXIV.Component.GUI;

namespace RustExporter;

public class Exporter
{
    public static string Indent(int level)
    {
        return new string(' ', level * 4);
    }

    #region singleton

    private static Exporter _exporter;
    public static Exporter Instance => _exporter ??= new Exporter();

    #endregion

    private readonly HashSet<Type> KnownTypes = new();
    private readonly RustRootModule RootModule = new() { Name = "root" };

    public static readonly string FFXIVNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.FFXIV), "" });

    public static readonly string HavokNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.Havok), "" });

    public static readonly string STDNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.STD), "" });

    public static readonly string InteropNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.Interop), "" });

    private Type[] GetExportableTypes(string assemblyName)
    {
        var assembly = AppDomain.CurrentDomain.Load(assemblyName);

        Type[] definedTypes;
        try
        {
            definedTypes = assembly.DefinedTypes.Select(ti => ti.AsType()).ToArray();
        }
        catch (ReflectionTypeLoadException ex)
        {
            definedTypes = ex.Types.Where(t => t != null).ToArray();
        }

        return definedTypes
            .Where(t => t.FullName.StartsWith(FFXIVNamespacePrefix) || t.FullName.StartsWith(HavokNamespacePrefix))
            .ToArray();
    }

    public string Export()
    {
        KnownTypes.Clear();

        var header = new StringBuilder();

        if (true)
        {
            var definedTypes = GetExportableTypes(nameof(FFXIVClientStructs));

            // Make forward references for everything, cycles are bad, detecting them is harder.
            // header.AppendLine("// Forward References");
            // foreach (var type in definedTypes)
            //     if (type.IsStruct() && !type.IsFixedBuffer())
            //         header.AppendLine($"struct {FixFullName(type)};");
            // header.AppendLine();
            // header.AppendLine("// Definitions");
            header.AppendLine("// This file is automatically generated by RustExporter. Do not edit manually.");
            foreach (var type in definedTypes)
            {
                ProcessType(type);
            }

            RootModule.Export(header, 0);
        }
        else
        {
            Console.WriteLine(RustTypeRef.ClrToRustName(typeof(AtkValue).GetField("Vector").FieldType));
        }

        return header.ToString();
    }

    private void ProcessType(Type type)
    {
        if (KnownTypes.Contains(type))
        {
            return;
        }

        // get the parent RustModule by iterating through the components of the namespace
        RustModule module = RootModule;
        var fullName = type.FullName;
        // if (fullName.Contains(" "))
        // {
        //     Console.WriteLine("LMAOWUT: " + fullName);
        //     return;
        // }

        if (fullName.StartsWith(FFXIVNamespacePrefix))
        {
            fullName = "ffxiv." + fullName.Remove(0, FFXIVNamespacePrefix.Length);
        }
        else if (fullName.StartsWith(HavokNamespacePrefix))
        {
            fullName = "havok." + fullName.Remove(0, HavokNamespacePrefix.Length);
        }
        else
        {
            // Interop / C++ STL types that we don't want to export
            return;
        }

        var components = fullName.Split('`')[0].Split('.');
        for (var i = 0; i < components.Length - 1; i++)
        {
            module = module.GetOrAddModule(components[i]);
        }

        if (type.IsFixedBuffer())
        {
            return;
        }
        else if (type.IsEnum)
        {
            ProcessEnum(type, module);
        }
        else if (type.IsStruct())
        {
            ProcessStruct(type, module);
        }
        else if (type.IsPrimitive)
        {
            ProcessPrimitive(type);
        }
        else
        {
            Debug.WriteLine($"Unhandled type: {type.FullName}");
        }
    }

    private static int GetEffectiveFieldSize(FieldInfo finfo)
    {
        if (finfo.IsFixed())
        {
            var fixedType = finfo.GetFixedType();
            var fixedSize = finfo.GetFixedSize();
            return SizeOf(fixedType) * fixedSize;
        }
        
        if (finfo.FieldType.IsPointer) return 8;
        if (finfo.FieldType.IsEnum) return SizeOf(Enum.GetUnderlyingType(finfo.FieldType));
        if (finfo.FieldType.IsGenericType) return Marshal.SizeOf(Activator.CreateInstance(finfo.FieldType));
        
        return SizeOf(finfo.FieldType);
    }

    private void ProcessStruct(Type type, RustModule module)
    {
        if (KnownTypes.Contains(type))
            return;

        if (type == typeof(void))
            return;

        Debug.WriteLine($"Processing Struct:  {type.FullName}");

        KnownTypes.Add(type);

        var rustType = (RustTypeRef)type;
        var baseTypeName = rustType.BaseName;

        if (baseTypeName.Contains("hkMatrix4f"))
        {
            Console.WriteLine("FOUND IT: " + rustType);
        }
        int structSize;
        if (type.IsGenericType)
        {
            if (type.ContainsGenericParameters)
            {
                Console.WriteLine("Has " + type.GetGenericArguments().Length + " generic params: " + rustType);
                // Generic types are ignored if they cannot be instantiated.
                var gls = new List<string>();
                for (int i = 1; i <= type.GetGenericArguments().Length; i++)
                {
                    gls.Add($"T{i}");
                }
                baseTypeName = baseTypeName.Replace("<>", $"<{string.Join(", ", gls)}>");
                
                var grs = new RustStruct(baseTypeName, 0);
                foreach (var s in gls)
                {
                    grs.Add($"__phantom_{s.ToLower()}", new RustTypeRef($"std::marker::PhantomData<{s}>"));
                }
                
                module.Add(baseTypeName, grs);
                return;
            }
            else
            {
                // don't add generic type usages
                // structSize = Marshal.SizeOf(Activator.CreateInstance(type));
                // Console.WriteLine("SKIP - Has no generic params: " + type.FullName);
                return;
            }
        }
        else
        {
            structSize = SizeOf(type);
        }

        var rs = new RustStruct(baseTypeName, structSize);

        var pad = structSize.ToString("X").Length;
        var padFill = new string(' ', pad + 2);

        var offset = 0;
        var fieldGroupings = type.GetFields()
            .Where(finfo => !Attribute.IsDefined(finfo, typeof(ObsoleteAttribute)))
            .Where(finfo => !finfo.IsLiteral) // not constants
            .Where(finfi => !finfi.IsStatic) // not static
            .OrderBy(finfo => finfo.GetFieldOffset())
            .GroupBy(finfo => finfo.GetFieldOffset());
        var unionIndex = 0;
        foreach (var grouping in fieldGroupings)
        {
            var fieldOffset = grouping.Key;
            if (offset < fieldOffset)
            {
                // skip these fields since they probably overlap with the previous field
                continue;
            }
            
            // todo: fix vtables, we ignore them for now
            var finfos = grouping
                .Where((finfo) => finfo.Name.ToLower() != "vtbl" && finfo.Name.ToLower() != "vtable")
                .OrderByDescending(GetEffectiveFieldSize)
                .ToList();

            var unionMaxSize = 0;
            var isUnion = finfos.Count > 1;
            RustStruct rsTarget = rs;

            var unionSuffix = "";
            if (isUnion)
            {
                unionSuffix = "_Union";
                if (unionIndex > 0)
                {
                    unionSuffix += $"_{unionIndex}";
                }

                unionIndex++;

                rsTarget = new RustStruct(baseTypeName + unionSuffix, 0, true);
                module.Add(rsTarget.Name, rsTarget);
            }

            for (int i = 0; i < finfos.Count; i++)
            {
                var finfo = finfos[i];
                var fieldType = finfo.FieldType;
                var fieldSize = GetEffectiveFieldSize(finfo);

                if (!isUnion)
                    offset = FillGaps(offset, fieldOffset, padFill, rs);

                if (offset > fieldOffset)
                {
                    Debug.WriteLine(
                        $"Current offset exceeded the next field's offset (0x{offset:X} > 0x{fieldOffset:X}): {RustTypeRef.ClrToRustName(type)}.{finfo.Name}");
                    break;
                }

                RustTypeRef rustTypeRef;
                if (finfo.IsFixed())
                {
                    var fixedType = finfo.GetFixedType();
                    var fixedSize = finfo.GetFixedSize();
                    ProcessType(fixedType);

                    rustTypeRef = new RustTypeRef(RustTypeRef.ClrToRustName(fixedType), fixedSize);
                }
                else
                {
                    rustTypeRef = new RustTypeRef(RustTypeRef.ClrToRustName(fieldType));
                }
                
                if (fieldType.IsPointer)
                {
                    var elemType = fieldType.GetElementType();
                    while (elemType.IsPointer)
                        elemType = elemType.GetElementType();
                    ProcessType(elemType);
                }
                
                ProcessType(fieldType);
                rsTarget.Add(RustTypeRef.SafeSnakeCase(finfo.Name), rustTypeRef, string.Format($"0x{{0:X{pad}}}", offset));

                if (isUnion)
                {
                    unionMaxSize = Math.Max(unionMaxSize, 8);
                    unionMaxSize = Math.Max(unionMaxSize, fieldSize);
                }
                else
                {
                    offset += fieldSize;
                }
            }

            if (isUnion)
            {
                rs.Add($"_union_0x{offset:x}", new RustTypeRef(rustType + unionSuffix), string.Format($"0x{{0:X{pad}}}", offset));
                offset += unionMaxSize;
            }
        }

        FillGaps(offset, structSize, padFill, rs);
        module.Add(baseTypeName, rs);
    }

    private static int SizeOf(Type type)
    {
        // Marshal.SizeOf doesn't work correctly because the assembly is unmarshaled, and more specifically, it sets bools as 4 bytes long...
        return (int?)typeof(Unsafe).GetMethod("SizeOf")?.MakeGenericMethod(type).Invoke(null, null) ?? 0;
    }

    private void ProcessEnum(Type type, RustModule module)
    {
        if (KnownTypes.Contains(type))
            return;

        KnownTypes.Add(type);

        Debug.WriteLine($"Processing Enum:  {type.FullName}");

        var baseTypeName = GetBaseName(RustTypeRef.ClrToRustName(type));
        var rs = new RustEnum(baseTypeName, RustTypeRef.ClrToRustName(type.GetEnumUnderlyingType()));

        try
        {
            var values = Enum.GetValues(type);
            for (int i = 0; i < values.Length; i++)
            {
                var value = values.GetValue(i);
                var name = Enum.GetName(type, value);
                rs.Add(name, $"{value:D}");
            }
        }
        catch
        {
            // ignored for now (due to hkArrayFlags)
        }

        module.Add(baseTypeName, rs);
    }

    private void ProcessPrimitive(Type type)
    {
        if (KnownTypes.Contains(type))
            return;

        // Debug.WriteLine($"Processing Primitive: {type.FullName}");

        KnownTypes.Add(type);
    }

    public static string GetBaseName(string name)
    {
        var parts = name.Split("::");
        return parts[^1];
    }

    private int FillGaps(int offset, int maxOffset, string padFill, RustStruct rs)
    {
        int gap;
        while ((gap = maxOffset - offset) > 0)
        {
            if (offset % 8 == 0 && gap >= 8)
            {
                var gapDiv = gap - (gap % 8);
                rs.Add($"_gap_0x{offset:x}", new RustTypeRef("u8", gapDiv), padFill);
                offset += gapDiv;
            }
            else if (offset % 4 == 0 && gap >= 4)
            {
                rs.Add($"_gap_0x{offset:x}", new RustTypeRef("u8", 4), padFill);
                offset += 4;
            }
            else if (offset % 2 == 0 && gap >= 2)
            {
                rs.Add($"_gap_0x{offset:x}", new RustTypeRef("u8", 2), padFill);
                offset += 2;
            }
            else
            {
                rs.Add($"_gap_0x{offset:x}", new RustTypeRef("u8"), padFill);
                offset += 1;
            }
        }

        return offset;
    }
}