using System.Collections.Immutable;
using System.Diagnostics;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;
using FFXIVClientStructs.FFXIV.Component.GUI;

namespace RustExporter;

public class Exporter
{
    // immutable set of all rust keywords
    public static readonly ImmutableHashSet<string> RustKeywords = ImmutableHashSet.Create(new[]
    {
        "as", "break", "const", "continue", "crate", "else", "enum", "extern", "false", "fn", "for", "if", "impl",
        "in", "let", "loop", "match", "mod", "move", "mut", "pub", "ref", "return", "self", "Self", "static",
        "struct", "super", "trait", "true", "type", "unsafe", "use", "where", "while", "async", "await", "dyn",
        "abstract", "become", "box", "do", "final", "macro", "override", "priv", "typeof", "unsized", "virtual",
        "yield", "try"
    });

    public static string Indent(int level)
    {
        return new string(' ', level * 4);
    }

    public static string ToRustName(string input)
    {
        // generally converts UpperCamelCase to snake_case, except for subsequent uppercase letters

        var sb = new StringBuilder();
        for (var i = 0; i < input.Length; i++)
        {
            char c = input[i];
            if (char.IsUpper(c))
            {
                if (i > 0 && char.IsUpper(input[i - 1]))
                {
                    sb.Append(char.ToLower(c));
                }
                else
                {
                    if (i > 0) sb.Append('_');
                    sb.Append(char.ToLower(c));
                }
            }
            else
            {
                sb.Append(c);
            }
        }

        var built = sb.ToString();

        // if the name matches any Rust keywords, suffix it with an underscore
        if (RustKeywords.Contains(built))
        {
            built += "_";
        }

        return built;
    }

    #region singleton

    private static Exporter _exporter;
    public static Exporter Instance => _exporter ??= new Exporter();

    #endregion

    private readonly HashSet<Type> KnownTypes = new();
    private readonly RustRootModule RootModule = new() { Name = "root" };

    public static readonly string FFXIVNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.FFXIV), "" });

    public static readonly string HavokNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.Havok), "" });

    public static readonly string STDNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.STD), "" });

    public static readonly string InteropNamespacePrefix = string.Join(".",
        new string[] { nameof(FFXIVClientStructs), nameof(FFXIVClientStructs.Interop), "" });

    private Type[] GetExportableTypes(string assemblyName)
    {
        var assembly = AppDomain.CurrentDomain.Load(assemblyName);

        Type[] definedTypes;
        try
        {
            definedTypes = assembly.DefinedTypes.Select(ti => ti.AsType()).ToArray();
        }
        catch (ReflectionTypeLoadException ex)
        {
            definedTypes = ex.Types.Where(t => t != null).ToArray();
        }

        return definedTypes
            .Where(t => t.FullName.StartsWith(FFXIVNamespacePrefix) || t.FullName.StartsWith(HavokNamespacePrefix))
            .ToArray();
    }

    public string Export()
    {
        KnownTypes.Clear();

        var header = new StringBuilder();

        if (true)
        {
            var definedTypes = GetExportableTypes(nameof(FFXIVClientStructs));

            // Make forward references for everything, cycles are bad, detecting them is harder.
            // header.AppendLine("// Forward References");
            // foreach (var type in definedTypes)
            //     if (type.IsStruct() && !type.IsFixedBuffer())
            //         header.AppendLine($"struct {FixFullName(type)};");
            // header.AppendLine();
            // header.AppendLine("// Definitions");
            header.AppendLine("// This file is automatically generated by RustExporter. Do not edit manually.");
            foreach (var type in definedTypes)
            {
                ProcessType(type);
            }

            RootModule.Export(header, 0);
        }
        else
        {
            Console.WriteLine(FixTypeName(typeof(AtkValue).GetField("Vector").FieldType));
        }

        return header.ToString();
    }

    private void ProcessType(Type type)
    {
        if (KnownTypes.Contains(type))
        {
            return;
        }

        // get the parent RustModule by iterating through the components of the namespace
        RustModule module = RootModule;
        var fullName = type.FullName;
        // if (fullName.Contains(" "))
        // {
        //     Console.WriteLine("LMAOWUT: " + fullName);
        //     return;
        // }

        if (fullName.StartsWith(FFXIVNamespacePrefix))
        {
            fullName = "ffxiv." + fullName.Remove(0, FFXIVNamespacePrefix.Length);
        }
        else if (fullName.StartsWith(HavokNamespacePrefix))
        {
            fullName = "havok." + fullName.Remove(0, HavokNamespacePrefix.Length);
        }
        else
        {
            // Interop / C++ STL types that we don't want to export
            return;
        }

        var components = fullName.Split('`')[0].Split('.');
        for (var i = 0; i < components.Length - 1; i++)
        {
            module = module.GetOrAddModule(components[i]);
        }

        if (type.IsFixedBuffer())
        {
            return;
        }
        else if (type.IsEnum)
        {
            ProcessEnum(type, module);
        }
        else if (type.IsStruct())
        {
            ProcessStruct(type, module);
        }
        else if (type.IsPrimitive)
        {
            ProcessPrimitive(type);
        }
        else
        {
            Debug.WriteLine($"Unhandled type: {type.FullName}");
        }
    }

    private void ProcessStruct(Type type, RustModule module)
    {
        if (KnownTypes.Contains(type))
            return;

        if (type == typeof(void))
            return;

        Debug.WriteLine($"Processing Struct:  {type.FullName}");

        KnownTypes.Add(type);

        var fullTypeName = FixFullName(type);
        var baseTypeName = GetBaseName(fullTypeName);

        int structSize;
        if (type.IsGenericType)
        {
            if (type.ContainsGenericParameters)
            {
                Console.WriteLine("Has " + type.GetGenericArguments().Length + " generic params: " + fullTypeName);
                // Generic types are ignored if they cannot be instantiated.
                var gls = new List<string>();
                for (int i = 1; i <= type.GetGenericArguments().Length; i++)
                {
                    gls.Add($"T{i}");
                }
                baseTypeName = baseTypeName.Replace("<>", $"<{string.Join(", ", gls)}>");
                
                var grs = new RustStruct(baseTypeName, 0);
                foreach (var s in gls)
                {
                    grs.Add($"__phantom_{s.ToLower()}: std::marker::PhantomData<{s}>");
                }
                
                module.Add(baseTypeName, grs);
                return;
            }
            else
            {
                // don't add generic type usages
                return;
                // structSize = Marshal.SizeOf(Activator.CreateInstance(type));
                // Console.WriteLine("Has no generic params: " + type.FullName);
            }
        }
        else
        {
            structSize = SizeOf(type);
        }

        var rs = new RustStruct(baseTypeName, structSize);

        var pad = structSize.ToString("X").Length;
        var padFill = new string(' ', pad + 2);

        var offset = 0;
        var fieldGroupings = type.GetFields()
            .Where(finfo => !Attribute.IsDefined(finfo, typeof(ObsoleteAttribute)))
            .Where(finfo => !finfo.IsLiteral) // not constants
            .Where(finfi => !finfi.IsStatic) // not static
            .OrderBy(finfo => finfo.GetFieldOffset())
            .GroupBy(finfo => finfo.GetFieldOffset());
        var unionIndex = 0;
        foreach (var grouping in fieldGroupings)
        {
            var fieldOffset = grouping.Key;
            var finfos = grouping.ToList();

            int unionMaxSize = 0;
            var isUnion = finfos.Count > 1;
            RustStruct rsTarget = rs;

            var unionSuffix = "";
            if (isUnion)
            {
                unionSuffix = "_Union";
                if (unionIndex > 0)
                {
                    unionSuffix += $"_{unionIndex}";
                }

                unionIndex++;

                rsTarget = new RustStruct(baseTypeName + unionSuffix, 0, true);
                module.Add(rsTarget.Name, rsTarget);
            }

            for (int i = 0; i < finfos.Count; i++)
            {
                var finfo = finfos[i];
                var fieldType = finfo.FieldType;
                int fieldSize = 0;

                if (!isUnion)
                    offset = FillGaps(offset, fieldOffset, padFill, rs);

                if (offset > fieldOffset)
                {
                    Debug.WriteLine(
                        $"Current offset exceeded the next field's offset (0x{offset:X} > 0x{fieldOffset:X}): {FixFullName(type)}.{finfo.Name}");
                    return;
                }

                if (finfo.IsFixed())
                {
                    var fixedType = finfo.GetFixedType();
                    var fixedSize = finfo.GetFixedSize();
                    ProcessType(fixedType);

                    rsTarget.Add(string.Format(
                        $"/* 0x{{0:X{pad}}} */ {ToRustName(finfo.Name)}: [{FixTypeName(fixedType)}; 0x{fixedSize:X}]",
                        offset));

                    fieldSize = SizeOf(fixedType) * fixedSize;
                }
                else if (fieldType.IsPointer)
                {
                    var elemType = fieldType.GetElementType();
                    while (elemType.IsPointer)
                        elemType = elemType.GetElementType();
                    ProcessType(elemType);

                    rsTarget.Add(string.Format(
                        $"/* 0x{{0:X{pad}}} */ {ToRustName(finfo.Name)}: {FixTypeName(fieldType)}", offset));

                    fieldSize = 8;
                }
                else
                {
                    ProcessType(fieldType);

                    rsTarget.Add(string.Format(
                        $"/* 0x{{0:X{pad}}} */ {ToRustName(finfo.Name)}: {FixTypeName(fieldType)}", offset));

                    if (fieldType == typeof(bool))
                        fieldSize = 1;
                    else if (fieldType.IsGenericType)
                        fieldSize = Marshal.SizeOf(Activator.CreateInstance(fieldType));
                    else if (fieldType.IsEnum)
                        fieldSize = SizeOf(Enum.GetUnderlyingType(fieldType));
                    else
                        fieldSize = SizeOf(fieldType);
                }

                if (isUnion)
                {
                    unionMaxSize = Math.Max(unionMaxSize, 8);
                }
                else
                {
                    offset += fieldSize;
                }
            }

            if (isUnion)
            {
                rs.Add(string.Format($"/* 0x{{0:X{pad}}} */ _union_0x{offset:x}: {fullTypeName}{unionSuffix}",
                    offset));
                offset += unionMaxSize;
            }
        }

        FillGaps(offset, structSize, padFill, rs);
        module.Add(baseTypeName, rs);
    }

    private int SizeOf(Type type)
    {
        // Marshal.SizeOf doesn't work correctly because the assembly is unmarshaled, and more specifically, it sets bools as 4 bytes long...
        return (int?)typeof(Unsafe).GetMethod("SizeOf")?.MakeGenericMethod(type).Invoke(null, null) ?? 0;
    }

    private void ProcessEnum(Type type, RustModule module)
    {
        if (KnownTypes.Contains(type))
            return;

        KnownTypes.Add(type);

        Debug.WriteLine($"Processing Enum:  {type.FullName}");

        var baseTypeName = GetBaseName(FixFullName(type));
        var rs = new RustEnum(baseTypeName, FixTypeName(type.GetEnumUnderlyingType()));

        // if (EnvFormat == EnvFormat.IDA)
        // {
        //     var underlyingTypeName = FixTypeName(type.GetEnumUnderlyingType());
        //     sb.AppendLine($"enum {type.Name}: {underlyingTypeName}");
        // }
        // else
        // {
        //     var underlyingType = type.GetEnumUnderlyingType();
        //     var fixedTypeName = FixTypeName(type);
        //     sb.AppendLine($"enum {fixedTypeName} /* Size=0x{SizeOf(underlyingType):X} */");
        // }

        try
        {
            var values = Enum.GetValues(type);
            for (int i = 0; i < values.Length; i++)
            {
                var value = values.GetValue(i);
                var name = Enum.GetName(type, value);
                rs.Add(name, $"{value:D}");
            }
        }
        catch
        {
            // ignored for now (due to hkArrayFlags)
        }

        module.Add(baseTypeName, rs);
    }

    private void ProcessPrimitive(Type type)
    {
        if (KnownTypes.Contains(type))
            return;

        // Debug.WriteLine($"Processing Primitive: {type.FullName}");

        KnownTypes.Add(type);
    }

    public static string GetBaseName(string name)
    {
        var parts = name.Split("::");
        return parts[^1];
    }

    public static string FixFullName(Type type)
    {
        string fullName;
        var isPrimitive = false;
        if (type.IsGenericType || (type.IsPointer && type.GetElementType().IsGenericType))
        {
            
            // todo: fix generics
            bool isPointer = type.IsPointer;
            var dereferenced = isPointer ? type.GetElementType() : type;
            var generic = dereferenced.GetGenericTypeDefinition();
            
            if (type.FullName.StartsWith(typeof(FFXIVClientStructs.Interop.Pointer<>).FullName))
            {
                fullName = FixTypeName(dereferenced.GenericTypeArguments[0]) + '*';
                isPrimitive = true; // todo this won't always be correct, probably need to refactor
            }
            else
            {
                fullName = generic.FullName.Split('`')[0];
                // if (isPointer) fullName = "*mut " + fullName;
                if (dereferenced.IsNested)
                {
                    fullName += '+' + generic.FullName.Split('+')[1].Split('[')[0];
                }

                fullName += '<';

                if (dereferenced.GenericTypeArguments.Length > 0)
                {
                    var fixedNames = new List<string>();
                    foreach (var argType in dereferenced.GenericTypeArguments)
                    {
                        fixedNames.Add(FixTypeName(argType));
                    }

                    fullName += string.Join(", ", fixedNames);
                }

                fullName += '>';
            }
        }
        else
        {
            fullName = type.FullName;
        }

        // Console.WriteLine("FULL: " + fullName);
        if (fullName.StartsWith(FFXIVNamespacePrefix))
        {
            fullName = fullName.Remove(0, FFXIVNamespacePrefix.Length);
            fullName = "ffxiv." + fullName;
        }

        if (fullName.StartsWith(HavokNamespacePrefix))
        {
            fullName = fullName.Remove(0, HavokNamespacePrefix.Length);
            fullName = "havok." + fullName;
        }
        
        if (fullName.StartsWith(STDNamespacePrefix))
        {
            // Console.WriteLine("STD:  " + fullName);
            fullName = fullName.Remove(0, STDNamespacePrefix.Length);
            if (fullName.StartsWith("Std"))
            {
                fullName = fullName.Remove(0, 3);
            }

            fullName = "cpp_std." + fullName;
        }

        if (fullName.StartsWith(InteropNamespacePrefix))
            fullName = fullName.Remove(0, InteropNamespacePrefix.Length);

        if (fullName.Contains("FFXIVClientStructs, Version"))
        {
            if (fullName.EndsWith("*"))
            {
                fullName = "*mut std::ffi::c_void";
            }
            else
            {
                throw new Exception($"Failed to fix name: {fullName}");
            }
        }

        // This is a hack because Ghidra doesn't support specifying the enum size
        // By appending 0x<size> on the enum name, it makes it easier to manually go
        // in and fix the sizes up after the fact.
        // if (EnvFormat == EnvFormat.Ghidra && type.IsEnum)
        // {
        //     var underlyingType = type.GetEnumUnderlyingType();
        //     fullName += $"0x{SizeOf(underlyingType):X}";
        // }

        // snake-case all components except for the last one
        var parts = fullName.Split('.');
        for (int i = 0; i < parts.Length - 1; i++)
        {
            parts[i] = ToRustName(parts[i]);
        }

        fullName = string.Join(".", parts);
        fullName = fullName.Replace(".", "::").Replace("+", "_");
        if (!isPrimitive) fullName = "crate::" + fullName;

        // execute twice to account for double-pointers
        for (var i = 0; i < 2; i++)
        {
            if (fullName.EndsWith('*'))
            {
                fullName = string.Concat("*mut ", fullName.AsSpan(0, fullName.Length - 1));
            }
        }
        
        if (type.IsPointer)
        {
            fullName = "*mut " + fullName;
        }

        return fullName;
    }

    private static string FixTypeName(Type type)
    {
        if (type == typeof(void))
        {
            // probably a return value
            return "()";
        }

        if (type == typeof(void*)) return "*mut std::ffi::c_void";
        if (type == typeof(void**)) return "*mut *mut std::ffi::c_void";
        if (type == typeof(char) || type == typeof(byte) || type == typeof(sbyte)) return "i8";
        if (type == typeof(char*) || type == typeof(byte*)) return "*mut i8";
        if (type == typeof(char**) || type == typeof(byte**)) return "*mut *mut i8";
        if (type == typeof(bool)) return "bool";
        if (type == typeof(float)) return "f32";
        if (type == typeof(double)) return "f64";
        if (type == typeof(short)) return "i16";
        if (type == typeof(int)) return "i32";
        if (type == typeof(long)) return "i64";
        if (type == typeof(ushort)) return "u16";
        if (type == typeof(uint)) return "u32";
        if (type == typeof(ulong)) return "u64";
        if (type == typeof(IntPtr)) return "*mut usize"; // todo?
        if (type == typeof(short*)) return "*mut i16";
        if (type == typeof(ushort*)) return "*mut u16";
        if (type == typeof(int*)) return "*mut i32";
        if (type == typeof(uint*)) return "*mut u32";
        if (type == typeof(Single*)) return "*mut f32";

        return FixFullName(type);
    }

    private int FillGaps(int offset, int maxOffset, string padFill, RustStruct rs)
    {
        int gap;
        while ((gap = maxOffset - offset) > 0)
        {
            // if (GapStrategy == GapStrategy.FullSize)
            // {
            //     if (offset % 8 == 0 && gap >= 8)
            //     {
            //         sb.AppendLine($"    /* {padFill} */ __int64 _gap_0x{offset:X};");
            //         offset += 8;
            //     }
            //     else if (offset % 4 == 0 && gap >= 4)
            //     {
            //         sb.AppendLine($"    /* {padFill} */ __int32 _gap_0x{offset:X};");
            //         offset += 4;
            //     }
            //     else if (offset % 2 == 0 && gap >= 2)
            //     {
            //         sb.AppendLine($"    /* {padFill} */ __int16 _gap_0x{offset:X};");
            //         offset += 2;
            //     }
            //     else
            //     {
            //         sb.AppendLine($"    /* {padFill} */ byte _gap_0x{offset:X};");
            //         offset += 1;
            //     }
            // }
            // else if (GapStrategy == GapStrategy.ByteArray)
            // {
            if (offset % 8 == 0 && gap >= 8)
            {
                var gapDiv = gap - (gap % 8);
                rs.Add($"/* {padFill} */ _gap_0x{offset:x}: [u8; 0x{gapDiv:X}]");
                offset += gapDiv;
            }
            else if (offset % 4 == 0 && gap >= 4)
            {
                rs.Add($"/* {padFill} */ _gap_0x{offset:x}: [u8; 0x4]");
                offset += 4;
            }
            else if (offset % 2 == 0 && gap >= 2)
            {
                rs.Add($"/* {padFill} */ _gap_0x{offset:x}: [u8; 0x2]");
                offset += 2;
            }
            else
            {
                rs.Add($"/* {padFill} */ _gap_0x{offset:x}: u8");
                offset += 1;
            }
            // }
            // else
            // {
            //     throw new Exception($"Unknown GapStrategy {GapStrategy}");
            // }
        }

        return offset;
    }
}