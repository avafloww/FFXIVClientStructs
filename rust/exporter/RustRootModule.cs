using System.Diagnostics;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using FFXIVClientStructs;

namespace RustExporter;

public class RustRootModule : RustModule
{
    public static readonly RustRootModule Instance = new();

    public RustRootModule() : base(null, "crate")
    {
    }

    public void ProcessCopyTaints()
    {
        int tainted;
        for (var i = 0;; i++)
        {
            tainted = GetAllStructsRecursive()
                .Where(rs => rs.TypeRefs.Any(typeRef => typeRef.Declaration.IsCopyTainted))
                .Sum(rs => rs.MarkAsCopyTainted());

            Console.WriteLine($"ProcessCopyTaints (pass {i}): {tainted} newly copy-tainted structs");
            if (i > 0 && tainted == 0)
            {
                break;
            }
        }
    }

    // virtual functions only get exported on the most derived types
    // i.e., we want to export AtkUnitBase vfs on AddonSelectString, but not on AtkUnitBase
    // Rust has no struct inheritance, so we need to collect the .NET types, remove virtual functions from base Rust types,
    // and then export the virtual functions on the most derived types
    public void ProcessVirtualFunctions()
    {
        foreach (var rs in GetAllStructsRecursive().Where(rs => rs.OriginalClrType != null))
        {
            // we don't need to touch anything if the vtable signature is valid
            if (rs.VTableSignature != null) continue;

            // check for any virtual functions and remove them from the base type
            var virtualFunctions = rs.Functions.Where(fn => fn.VirtualFunction != null).ToList();
            if (virtualFunctions.Count == 0) continue;

            // remove virtual functions from the base type
            foreach (var fn in virtualFunctions)
            {
                rs.Functions.Remove(fn);
            }

            // spread them to subtypes (recursively) with valid vtable signatures
            foreach (var subStruct in GetAllStructsRecursive()
                         .Where(subStruct => subStruct.OriginalClrType != null)
                         .Where(subStruct => subStruct.VTableSignature != null))
            {
                // is this a subtype of the original struct?
                // this is defined as a substruct if any field with FieldOffset[0] is of the original type
                if (!subStruct.OriginalClrType!
                        .GetFields()
                        .Where(finfo => !Attribute.IsDefined(finfo, typeof(ObsoleteAttribute)))
                        .Where(finfo => !Attribute.IsDefined(finfo, typeof(CExportIgnoreAttribute)))
                        .Where(finfo => finfo.FieldType == rs.OriginalClrType)
                        .Any(finfo => finfo.GetCustomAttribute<FieldOffsetAttribute>()?.Value == 0))
                {
                    continue;
                }

                // add virtual functions to the subtype
                foreach (var fn in virtualFunctions)
                {
                    // only add the function if it doesn't already exist
                    if (subStruct.Functions.Any(subFn => subFn.Name == fn.Name)) continue;
                    subStruct.Functions.Add(RustFunction.FromBaseMethod(fn, subStruct));
                }

                Console.WriteLine($"ProcessVirtualFunctions: base {rs.Name} -> {subStruct.Name}");
            }
        }
    }

    public override void Export(StringBuilder builder, int indentLevel)
    {
        // Get the current git commit hash of the repo, appending "-dirty" for uncommitted changes
        var gitProcess = new Process
        {
            StartInfo =
            {
                FileName = "git",
                Arguments = "describe --always --dirty",
                UseShellExecute = false,
                RedirectStandardOutput = true,
                CreateNoWindow = true
            }
        };
        gitProcess.Start();
        gitProcess.WaitForExit();

        var gitOutput = gitProcess.StandardOutput.ReadToEnd().Trim();
        builder.AppendLine($"// rev: {gitOutput}");
        builder.AppendLine("// This file is automatically generated by RustExporter. Do not edit manually.");
        builder.AppendLine("#![allow(warnings)]");
        builder.AppendLine(
            "use crate::{ResolvableStaticAddress, ResolvableMemberFunction, ResolvableVTable, ResolvableVirtualFunction};");
        builder.AppendLine("use crate::address::{Addressable, get_address};");
        builder.AppendLine("use crate::internal::*;");

        // export helper functions
        var indent = Exporter.Indent(indentLevel + 1);

        ExportVTableResolver(builder, indent, false);
        ExportVTableResolver(builder, indent, true);

        ExportStaticAddressResolver(builder, indent, false);
        ExportStaticAddressResolver(builder, indent, true);

        ExportMemberFunctionResolver(builder, indent, false);
        ExportMemberFunctionResolver(builder, indent, true);

        // export members
        foreach (var member in _members)
        {
            member.Value.Export(builder, indentLevel);
        }
    }

    private void ExportVTableResolver(StringBuilder builder, string indent, bool async)
    {
        // resolve vtables
        if (async)
        {
            builder.AppendLine("#[cfg(feature = \"async-resolution\")]");
            builder.AppendLine("pub(crate) async unsafe fn resolve_vtables_async(resolver: crate::VTableResolver) {");
            builder.AppendLine($"{indent}let mut tasks = tokio::task::JoinSet::new();");
        }
        else
        {
            builder.AppendLine("pub(crate) unsafe fn resolve_vtables(resolver: crate::VTableResolver) {");
        }

        var prefix = async ? "tasks.spawn(" : "";
        var suffix = async ? ");" : ";";
        var fnSuffix = async ? "_async" : "";
        foreach (var rs in GetAllStructsRecursive()
                     .Where(rs => rs.VTableSignature != null))
        {
            builder.AppendLine(
                $"{indent}{prefix}resolve_vtable{fnSuffix}(&{rs.Name}::KEY, &{rs.Name}::SIGNATURE, resolver){suffix}");
        }

        if (async)
        {
            builder.AppendLine($"{indent}while let Some(_) = tasks.join_next().await {{}}");
        }

        builder.AppendLine("}");
    }

    private void ExportStaticAddressResolver(StringBuilder builder, string indent, bool async)
    {
        // resolve static addresses
        if (async)
        {
            builder.AppendLine("#[cfg(feature = \"async-resolution\")]");
            builder.AppendLine(
                "pub(crate) async unsafe fn resolve_static_addresses_async(resolver: crate::StaticAddressResolver) {");
            builder.AppendLine($"{indent}let mut tasks = tokio::task::JoinSet::new();");
        }
        else
        {
            builder.AppendLine(
                "pub(crate) unsafe fn resolve_static_addresses(resolver: crate::StaticAddressResolver) {");
        }

        var prefix = async ? "tasks.spawn(" : "";
        var suffix = async ? ");" : ";";
        var fnSuffix = async ? "_async" : "";
        foreach (var fn in GetAllStructsRecursive()
                     .SelectMany(rs => rs.Functions)
                     .Where(fn => fn.StaticAddress != null))
        {
            builder.AppendLine(
                $"{indent}{prefix}resolve_static_address{fnSuffix}(&{fn.FullGeneratedName}::KEY, &{fn.FullGeneratedName}::SIGNATURE, resolver){suffix}");
        }

        if (async)
        {
            builder.AppendLine($"{indent}while let Some(_) = tasks.join_next().await {{}}");
        }

        builder.AppendLine("}");
    }

    private void ExportMemberFunctionResolver(StringBuilder builder, string indent, bool async)
    {
        var prefix = async ? "tasks.spawn(" : "";
        var suffix = async ? ");" : ";";
        var fnSuffix = async ? "_async" : "";

        // resolve member functions
        if (async)
        {
            builder.AppendLine("#[cfg(feature = \"async-resolution\")]");
            builder.AppendLine(
                "pub(crate) async unsafe fn resolve_member_functions_async(resolver: crate::MemberFunctionResolver) {");
            builder.AppendLine($"{indent}let mut tasks = tokio::task::JoinSet::new();");
        }
        else
        {
            builder.AppendLine(
                "pub(crate) unsafe fn resolve_member_functions(resolver: crate::MemberFunctionResolver) {");
        }

        builder.AppendLine($"{indent}// resolve member functions with signatures");
        foreach (var fn in GetAllStructsRecursive()
                     .SelectMany(rs => rs.Functions)
                     .Where(fn => fn.MemberFunction != null))
        {
            builder.AppendLine(
                $"{indent}{prefix}resolve_member_function{fnSuffix}(&{fn.FullGeneratedName}::KEY, &{fn.FullGeneratedName}::SIGNATURE, resolver){suffix}");
        }

        builder.AppendLine();
        builder.AppendLine($"{indent}// resolve member functions by vtable index");
        foreach (var fn in GetAllStructsRecursive()
                     .SelectMany(rs => rs.Functions)
                     .Where(fn => fn.VirtualFunction != null))
        {
            builder.AppendLine(
                $"{indent}{prefix}resolve_virtual_function{fnSuffix}(&{fn.FullGeneratedName}::KEY, &{fn.Owner.Name}::KEY, {fn.VirtualFunction!.Index}){suffix}");
        }

        if (async)
        {
            builder.AppendLine($"{indent}while let Some(_) = tasks.join_next().await {{}}");
        }

        builder.AppendLine("}");
    }
}
